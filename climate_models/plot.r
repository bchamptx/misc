# Climate models versus satellite observations

# add alpha (transparency) to a color
add.alpha <- function(col, alpha=1)
{
  if (missing (col))
    stop ("Please provide a vector of colours.")
  apply (sapply (col, col2rgb)/255, 2, 
         function(x) 
           rgb(x[1], x[2], x[3], alpha=alpha))  
}

pink <- add.alpha("red",0.4)
blue <- add.alpha("blue", 0.4)

model_mean <- 0.272
model_sd <- 0.058
sd_to_fill <- 6
model_lower_bound <- model_mean - (model_sd * sd_to_fill)
model_upper_bound <- model_mean + (model_sd * sd_to_fill)

observations_mean <- 0.095
observations_sd <- 0.049
observations_lower_bound <- observations_mean - (observations_sd * sd_to_fill)
observations_upper_bound <- observations_mean + (observations_sd * sd_to_fill)

# Generates equally spaced values within 8 standard deviations of the mean
# This is used to connect the points on the curve so the more points the better
model_values_x <- seq (-8, 8, length = 1000) * model_sd + model_mean
observations_values_x <- seq (-8, 8, length = 1000) * observations_sd + observations_mean

# Returns the height of the probably distribution at each of those points
model_values_y <- dnorm(model_values_x, model_mean, model_sd)
observations_values_y <- dnorm(observations_values_x, observations_mean, observations_sd)

# Generate the plot, where:
# - type: the type of plot to be drawn where "n" means do not plot the points
# - xlab: the title of the x axis
# - ylab: the title of the y axis
# - main: the overall title for the plot
# - axes: when false it suppresses the axis automatically generated by the high level plotting function so that we can create custom axis
par(mar=c(5.1,5.1,4.1,2.1))
plot(model_values_x, model_values_y, type="n", xlim=c(-0.1,0.5), ylim=c(0,10), xlab = "Temperature Increase (C°)", ylab = "", main = "Climate Models v. Observations", axes = TRUE, cex.main=3, cex.lab=2, cex.axis=2)
plot(observations_values_x, observations_values_y, type="n", xlim=c(-0.1,0.5), ylim=c(0,10), xlab = "Temperature Increase (C°)", ylab = "", main = "Climate Models v. Observations", axes = TRUE, cex.main=3, cex.lab=2, cex.axis=2)
title(ylab="Probability Density", line=3, cex.lab=2)


grid(NULL, NULL, col="lightgray", lty=1)

# Connect all of the points with each other to form the bell curve
#lines(model_values_x, model_values_y)
#lines(observations_values_x, observations_values_y)

# Returns a vector of boolean values representing whether the x value is between the two bounds then
# filters the values so that only the ones within the bounds are returned
model_bounds_filter <- model_values_x >= model_lower_bound & model_values_x <= model_upper_bound
model_x_within_bounds <- model_values_x[model_bounds_filter]
model_y_within_bounds <- model_values_y[model_bounds_filter]

observations_bounds_filter <- observations_values_x >= observations_lower_bound & observations_values_x <= observations_upper_bound
observations_x_within_bounds <- observations_values_x[observations_bounds_filter]
observations_y_within_bounds <- observations_values_y[observations_bounds_filter]

# We want the filled in area to extend all the way down to the y axis which is why these two lines are necessary
# It makes the first point in the polygon (lower_bound, 0) and the last point (upper_bound, 0)
model_x_polygon <- c(model_lower_bound, model_x_within_bounds, model_upper_bound)
model_y_polygon <- c(0, model_y_within_bounds, 0)
polygon(model_x_polygon, model_y_polygon, col=pink, border=pink)

observations_x_polygon <- c(observations_lower_bound, observations_x_within_bounds, observations_upper_bound)
observations_y_polygon <- c(0, observations_y_within_bounds, 0)
polygon(observations_x_polygon, observations_y_polygon, col=blue, border=blue)

# Now determine the probability that a value falls between the two bounds so we can display it above the curve
# Remember that pnorm returns the probability that a normally distributed random number will be less than the given number
probability_within_bounds <- pnorm(model_upper_bound, model_mean, model_sd) - pnorm(model_lower_bound, model_mean, model_sd)

# Concatenate the various values so we can display it on the curve
# text <- paste("p(", model_lower_bound, "< temperature increase <", upper_bound, ") =", signif(probability_within_bounds, digits = 3))

# Display the text on the plot. The default "side" parameter is 3, representing the top of the plot.
#mtext(text)


text(0,9,"Actual Observations",pos=3, cex=3)
arrows(0,9, observations_mean, 5, length=0.15)

text(0.375,9,"Model Predictions",pos=3, cex=3)
arrows(0.375, 9, model_mean, 5, length=0.15)

# Add an axis to the current plot, where:
# - side: which side of the plot the axis should be drawn on where 1 represents the bottom
# - at: the points at which the tick-marks are to be drawn
# - pos: the coordinate at which the axis line is to be drawn
sd_axis_bounds = 5
axis_bounds <- seq(-sd_axis_bounds * model_sd + model_mean, sd_axis_bounds * model_sd + model_mean, by = model_sd)
#axis(side = 1, at = axis_bounds, pos = 0)

